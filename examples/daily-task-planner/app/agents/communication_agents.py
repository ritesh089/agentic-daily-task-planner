"""
Communication Agent Module (MCP-based)
Handles sending summaries and todo lists via MCP tools
"""

from typing import Dict
from datetime import datetime
from framework import run_async_tool_call


# ============================================================================
# Email Sender Agent (MCP-based)
# ============================================================================

def email_sender_agent(state: Dict) -> Dict:
    """
    Sends prioritized todo list via email using MCP email server
    Uses the 'send_email' tool provided by the email MCP server
    """
    print("üì® Email Sender (MCP): Preparing to send todo list...")
    
    prioritized_tasks = state['prioritized_tasks']
    
    if not prioritized_tasks:
        print("‚ÑπÔ∏è  No tasks to send - skipping email")
        state['email_sent'] = False
        state['email_status'] = "No tasks to send"
        return state
    
    try:
        # Format email content
        email_body = format_todo_email(prioritized_tasks, state['time_range_hours'])
        
        # For MCP, we need to determine the recipient
        # In a real scenario, this would be configured or extracted from state
        # For now, we'll use a placeholder that the MCP server can handle
        recipient = state.get('user_email', 'me@example.com')
        
        # Call MCP tool to send email
        result = run_async_tool_call(
            server_name="email",
            tool_name="send_email",
            arguments={
                "to": recipient,
                "subject": f"üéØ Your Prioritized Todo List - {datetime.now().strftime('%b %d, %Y')}",
                "body_text": email_body['text'],
                "body_html": email_body.get('html', '')
            }
        )
        
        if result.get('success'):
            state['email_sent'] = True
            state['email_status'] = f"Successfully sent to {recipient}"
            state['email_message_id'] = result.get('message_id', '')
            
            is_mock = result.get('mock', False)
            mock_label = "[MOCK] " if is_mock else ""
            
            print(f"‚úì {mock_label}Todo list sent to {recipient}")
        else:
            error_msg = result.get('error', 'Unknown error')
            print(f"‚úó Email sending failed: {error_msg}")
            state.setdefault('errors', []).append(f"Email sending: {error_msg}")
            state['email_sent'] = False
            state['email_status'] = error_msg
    
    except Exception as e:
        error_msg = f"MCP tool call failed: {str(e)}"
        print(f"‚úó {error_msg}")
        state.setdefault('errors', []).append(error_msg)
        state['email_sent'] = False
        state['email_status'] = error_msg
    
    return state


# ============================================================================
# Email Formatting Helper
# ============================================================================

def format_todo_email(tasks, time_range_hours):
    """Formats todo list for email (both plain text and HTML)"""
    
    # Group by priority
    priority_groups = {'P0': [], 'P1': [], 'P2': [], 'P3': []}
    for task in tasks:
        priority = task.get('priority', 'P3')
        priority_groups[priority].append(task)
    
    # Plain text version
    text_lines = []
    text_lines.append(f"Your Prioritized Todo List")
    text_lines.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    text_lines.append(f"Time Range: Last {time_range_hours} hours")
    text_lines.append(f"Total Tasks: {len(tasks)}")
    text_lines.append("")
    text_lines.append("="*70)
    text_lines.append("")
    
    priority_labels = {
        'P0': 'CRITICAL',
        'P1': 'HIGH',
        'P2': 'MEDIUM',
        'P3': 'LOW'
    }
    
    for priority in ['P0', 'P1', 'P2', 'P3']:
        priority_tasks = priority_groups[priority]
        if priority_tasks:
            text_lines.append(f"{priority_labels[priority]} ({len(priority_tasks)} tasks)")
            text_lines.append("-" * 70)
            
            for i, task in enumerate(priority_tasks, 1):
                text_lines.append(f"\n{i}. {task['task']}")
                text_lines.append(f"   Requested by: {task['requested_by']} ({task['source']})")
                text_lines.append(f"   Action: {task.get('recommended_action', 'Review')}")
                text_lines.append(f"   Effort: {task.get('estimated_effort', 'Unknown')}")
                text_lines.append(f"   Why: {task.get('priority_reason', 'N/A')}")
            
            text_lines.append("")
    
    text_lines.append("="*70)
    text_lines.append("")
    text_lines.append("This email was automatically generated by your Multi-Agent Summarizer (MCP).")
    
    # HTML version
    html_lines = []
    html_lines.append("""
    <html>
    <head>
        <style>
            body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
            .header { background-color: #4A90E2; color: white; padding: 20px; border-radius: 5px; }
            .task-section { margin: 20px 0; }
            .priority-header { 
                padding: 10px; 
                border-radius: 5px; 
                margin: 15px 0 10px 0;
                font-weight: bold;
            }
            .p0 { background-color: #ff4444; color: white; }
            .p1 { background-color: #ff9944; color: white; }
            .p2 { background-color: #ffdd44; color: #333; }
            .p3 { background-color: #44dd44; color: white; }
            .task-card { 
                border-left: 4px solid #4A90E2; 
                padding: 15px; 
                margin: 10px 0; 
                background-color: #f9f9f9;
                border-radius: 3px;
            }
            .task-title { font-size: 16px; font-weight: bold; margin-bottom: 10px; }
            .task-meta { font-size: 14px; color: #666; margin: 5px 0; }
            .task-action { background-color: #e8f4f8; padding: 8px; border-radius: 3px; margin: 5px 0; }
            .footer { margin-top: 30px; padding: 15px; background-color: #f0f0f0; border-radius: 5px; font-size: 12px; color: #666; }
        </style>
    </head>
    <body>
        <div class="header">
            <h1>üéØ Your Prioritized Todo List</h1>
            <p>Generated: """ + datetime.now().strftime('%B %d, %Y at %I:%M %p') + """</p>
            <p>Time Range: Last """ + str(time_range_hours) + """ hours | Total Tasks: """ + str(len(tasks)) + """</p>
        </div>
    """)
    
    priority_emojis = {
        'P0': 'üî¥',
        'P1': 'üü†',
        'P2': 'üü°',
        'P3': 'üü¢'
    }
    
    priority_classes = {
        'P0': 'p0',
        'P1': 'p1',
        'P2': 'p2',
        'P3': 'p3'
    }
    
    for priority in ['P0', 'P1', 'P2', 'P3']:
        priority_tasks = priority_groups[priority]
        if priority_tasks:
            html_lines.append(f"""
            <div class="task-section">
                <div class="priority-header {priority_classes[priority]}">
                    {priority_emojis[priority]} {priority_labels[priority]} ({len(priority_tasks)} tasks)
                </div>
            """)
            
            for task in priority_tasks:
                html_lines.append(f"""
                <div class="task-card">
                    <div class="task-title">{task['task']}</div>
                    <div class="task-meta">üë§ Requested by: <strong>{task['requested_by']}</strong> ({task['source']})</div>
                    <div class="task-action">üìù <strong>Action:</strong> {task.get('recommended_action', 'Review')}</div>
                    <div class="task-meta">‚è±Ô∏è Effort: {task.get('estimated_effort', 'Unknown')}</div>
                    <div class="task-meta">üí° Why: {task.get('priority_reason', 'N/A')}</div>
                </div>
                """)
            
            html_lines.append("</div>")
    
    html_lines.append("""
        <div class="footer">
            <p>This email was automatically generated by your Multi-Agent Communication Summarizer (MCP).</p>
            <p>Reply to this email will go to your own inbox.</p>
        </div>
    </body>
    </html>
    """)
    
    return {
        'text': '\n'.join(text_lines),
        'html': ''.join(html_lines)
    }

